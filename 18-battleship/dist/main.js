/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/components/dom.js":
/*!*******************************!*\
  !*** ./src/components/dom.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ship = __webpack_require__(/*! ../components/ship */ \"./src/components/ship.js\");\r\nconst Gameboard = __webpack_require__(/*! ../components/gameboard */ \"./src/components/gameboard.js\");\r\n\r\nconst DOM = () => {\r\n\tconst SHIP_SQUARE_PX = 45;\r\n\tconst standard_ships = {\r\n\t\tdestroyer: Ship(2),\r\n\t\tsubmarine: Ship(3),\r\n\t\tcruiser: Ship(3),\r\n\t\tbattleship: Ship(4),\r\n\t\tcarrier: Ship(5),\r\n\t};\r\n\r\n\tlet gb_player = Gameboard();\r\n\tlet gb_cpu = Gameboard();\r\n\tlet dragged_ship = '';\r\n\tlet dragged_ship_square = -1;\r\n\tlet is_dragged_horiz = true;\r\n\tlet last_clicked_ship = false;\r\n\r\n\tlet can_start_game = false;\r\n\r\n\t// Check if the last thing the user has clicked is a ship\r\n\t// This is used to prevent them from dragging other elements into the player board\r\n\tconst _init_window = () => {\r\n\t\twindow.addEventListener('mousedown', (e) => {\r\n\t\t\tconst all_ship_names = Object.keys(standard_ships);\r\n\t\t\tfor (let i = 0; i < all_ship_names.length; i++) {\r\n\t\t\t\tif (e.target.classList.contains(all_ship_names[i])) {\r\n\t\t\t\t\tlast_clicked_ship = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlast_clicked_ship = false;\r\n\t\t});\r\n\t};\r\n\r\n\t// Checks if all ships have been placed, then starts the game\r\n\tconst _init_start_game_btn = () => {\r\n\t\tdocument\r\n\t\t\t.querySelector('.start-game-btn')\r\n\t\t\t.addEventListener('click', (e) => {\r\n\t\t\t\tconst all_ship_names = Object.keys(standard_ships);\r\n\t\t\t\tconst ship_elements = [];\r\n\t\t\t\tfor (let i = 0; i < all_ship_names.length; i++) {\r\n\t\t\t\t\tship_elements.push(\r\n\t\t\t\t\t\tdocument.querySelector('.' + all_ship_names[i])\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (let i = 0; i < ship_elements.length; i++) {\r\n\t\t\t\t\t// If a ship is not hidden, they haven't all been placed yet\r\n\t\t\t\t\t// and the game cannot start\r\n\t\t\t\t\tif (!ship_elements[i].classList.contains('hidden')) {\r\n\t\t\t\t\t\tcan_start_game = false;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcan_start_game = true;\r\n\t\t\t\te.target.disabled = true;\r\n\t\t\t\tgb_cpu.place_all_random(Object.values(standard_ships));\r\n\t\t\t});\r\n\t};\r\n\r\n\tconst _init_attack_squares = () => {\r\n\t\tconst squares = document.querySelectorAll('.attack-square');\r\n\t\tsquares.forEach((square) => {\r\n\t\t\tsquare.addEventListener('click', (e) => {\r\n\t\t\t\tmake_move(e);\r\n\t\t\t\tconsole.log('clicked');\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\tconst _init_ships = () => {\r\n\t\tconst ships = document.querySelectorAll('.ships > div > div');\r\n\t\tships.forEach((ship) => {\r\n\t\t\tship.addEventListener('contextmenu', (e) => {\r\n\t\t\t\tconsole.log('contextmenu', e.button);\r\n\t\t\t\te.preventDefault();\r\n\t\t\t\te.stopPropagation();\r\n\t\t\t\te.target.classList.toggle('vertical');\r\n\r\n\t\t\t\tconst vert = document.querySelector('.ships-vertical');\r\n\t\t\t\tconst horiz = document.querySelector('.ships-horizontal');\r\n\t\t\t\tif (e.target.classList.contains('vertical')) {\r\n\t\t\t\t\tvert.appendChild(ship);\r\n\t\t\t\t\tconsole.log(vert);\r\n\t\t\t\t} else {\r\n\t\t\t\t\thoriz.appendChild(ship);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tship.addEventListener('mousedown', (e) => {\r\n\t\t\t\t// Ignore right click\r\n\t\t\t\tif (e.button === 2) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlast_clicked_ship = true;\r\n\r\n\t\t\t\tconst rect = e.target.getBoundingClientRect();\r\n\t\t\t\tconst x = e.clientX - rect.left; //x position within the element.\r\n\t\t\t\tconst y = e.clientY - rect.top; //y position within the element.\r\n\r\n\t\t\t\tif (e.target.classList.contains('vertical')) {\r\n\t\t\t\t\tis_dragged_horiz = false;\r\n\r\n\t\t\t\t\tdragged_ship_square = Math.floor(y / SHIP_SQUARE_PX);\r\n\r\n\t\t\t\t\t// If click is on left or right edge, round down\r\n\t\t\t\t\tif (dragged_ship_square < 0) {\r\n\t\t\t\t\t\tdragged_ship_square = 0;\r\n\t\t\t\t\t} else if (\r\n\t\t\t\t\t\tdragged_ship_square ===\r\n\t\t\t\t\t\tstandard_ships[e.target.classList[0]].length\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tdragged_ship_square -= 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tis_dragged_horiz = true;\r\n\r\n\t\t\t\t\tdragged_ship_square = Math.floor(x / SHIP_SQUARE_PX);\r\n\r\n\t\t\t\t\t// If click is on left or right edge, round down\r\n\t\t\t\t\tif (dragged_ship_square < 0) {\r\n\t\t\t\t\t\tdragged_ship_square = 0;\r\n\t\t\t\t\t} else if (\r\n\t\t\t\t\t\tdragged_ship_square ===\r\n\t\t\t\t\t\tstandard_ships[e.target.classList[0]].length\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\tdragged_ship_square -= 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdragged_ship = e.target.classList[0];\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\r\n\tconst _init_restart_btn = () => {\r\n\t\tdocument.querySelector('.restart-btn').addEventListener('click', () => {\r\n\t\t\t// Clear boards\r\n\t\t\tdocument.querySelector('.player-board').innerHTML = '';\r\n\t\t\tdocument.querySelector('.attack-board').innerHTML = '';\r\n\t\t\tgb_player = Gameboard();\r\n\t\t\tgb_cpu = Gameboard();\r\n\r\n\t\t\t// Reset ships\r\n\t\t\tconst ships = document.querySelectorAll('.ships > div > div');\r\n\t\t\tships.forEach((ship) => {\r\n\t\t\t\tship.classList.remove('hidden');\r\n\t\t\t});\r\n\r\n\t\t\t// Reset start button\r\n\t\t\tdocument.querySelector('.start-game-btn').disabled = false;\r\n\r\n\t\t\t// Reset variables\r\n\t\t\tdragged_ship = '';\r\n\t\t\tdragged_ship_square = -1;\r\n\t\t\tis_dragged_horiz = true;\r\n\t\t\tlast_clicked_ship = false;\r\n\r\n\t\t\tcan_start_game = false;\r\n\r\n\t\t\t// Display board\r\n\t\t\t_display_boards();\r\n\t\t\t_init_attack_squares();\r\n\r\n\t\t\t// Display board titles\r\n\t\t\tconst player_title = document.createElement('h2');\r\n\t\t\tconst attack_title = document.createElement('h2');\r\n\t\t\tplayer_title.textContent = 'Player board';\r\n\t\t\tattack_title.textContent = 'Attack board';\r\n\t\t\tdocument.querySelector('.player-board').appendChild(player_title);\r\n\t\t\tdocument.querySelector('.attack-board').appendChild(attack_title);\r\n\r\n\t\t\t// Clear alert text\r\n\t\t\tdocument.querySelector('.alert').textContent = '';\r\n\t\t});\r\n\t};\r\n\r\n\tconst _init_info_btn = () => {\r\n\t\talert_text =\r\n\t\t\t\"\\\r\n\t\t\tRight click on ships to rotate them vertically or horizontally.\\n\\\r\n\t\t\tDrag the ships onto the player board to place them.\\n\\\r\n\t\t\tStart the game by pressing the start game button after placing all your ships.\\n\\\r\n\t\t\tClick on the attack board to attack the CPU's ships.\\n\\\r\n\t\t\tRed means a ship has been hit and blue means that an attack has missed.\\\r\n\t\t\t\";\r\n\r\n\t\tconst modal = document.querySelector('.info-modal');\r\n\t\tdocument.querySelector('.info-btn').addEventListener('click', () => {\r\n\t\t\tconsole.log('show modal');\r\n\t\t\tmodal.showModal();\r\n\t\t\tdocument.querySelector('.description').textContent = alert_text;\r\n\t\t});\r\n\r\n\t\tdocument\r\n\t\t\t.querySelector('dialog button')\r\n\t\t\t.addEventListener('click', () => {\r\n\t\t\t\tmodal.close();\r\n\t\t\t});\r\n\t};\r\n\r\n\tconst _player_move = (e) => {\r\n\t\tconst row = Number(e.target.getAttribute('data-row'));\r\n\t\tconst col = Number(e.target.getAttribute('data-col'));\r\n\r\n\t\t// Player has already attacked this square, ignore the click\r\n\t\tif (!gb_cpu.receive_attack(row, col)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Wrap in an array since _update_display takes NodeList\r\n\t\tconst attacked_square = [\r\n\t\t\tdocument.querySelector(\r\n\t\t\t\t`.attack-square[data-row=\"${row}\"][data-col=\"${col}\"]`\r\n\t\t\t),\r\n\t\t];\r\n\t\t_update_display(attacked_square, gb_cpu.grid[row][col]);\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// CPU's turn; generate a random coordinate to attack\r\n\tconst _cpu_move = () => {\r\n\t\tlet row = Math.floor(Math.random() * gb_player.grid.length);\r\n\t\tlet col = Math.floor(Math.random() * gb_player.grid[0].length);\r\n\r\n\t\t// Keep trying until a row and col pair is found that has not been attacked before\r\n\t\twhile (!gb_player.receive_attack(row, col)) {\r\n\t\t\trow = Math.floor(Math.random() * gb_player.grid.length);\r\n\t\t\tcol = Math.floor(Math.random() * gb_player.grid[0].length);\r\n\t\t}\r\n\r\n\t\tconst attacked_square = [\r\n\t\t\tdocument.querySelector(\r\n\t\t\t\t`.player-square[data-row=\"${row}\"][data-col=\"${col}\"]`\r\n\t\t\t),\r\n\t\t];\r\n\t\t_update_display(attacked_square, gb_player.grid[row][col]);\r\n\t};\r\n\r\n\tconst make_move = (e) => {\r\n\t\tif (!can_start_game) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconsole.log('ayayya');\r\n\r\n\t\tif (!_player_move(e)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Check if player wins\r\n\t\tif (gb_cpu.check_lose()) {\r\n\t\t\t_disable_board();\r\n\t\t\t_display_win();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t_cpu_move();\r\n\r\n\t\t// Check if player loses\r\n\t\tif (gb_player.check_lose()) {\r\n\t\t\t_disable_board();\r\n\t\t\t_display_lose();\r\n\t\t\treturn;\r\n\t\t}\r\n\t};\r\n\r\n\tconst _disable_board = () => {\r\n\t\tconst player_squares = document.querySelectorAll('.player-square');\r\n\t\tconst attack_squares = document.querySelectorAll('.attack-square');\r\n\r\n\t\tplayer_squares.forEach((sq) => {\r\n\t\t\tsq.style.pointerEvents = 'none';\r\n\t\t});\r\n\t\tattack_squares.forEach((sq) => {\r\n\t\t\tsq.style.pointerEvents = 'none';\r\n\t\t});\r\n\t};\r\n\r\n\tconst _display_lose = () => {\r\n\t\tconst alert_element = document.querySelector('.alert');\r\n\t\talert_element.classList.remove('description');\r\n\t\talert_element.textContent = 'CPU wins!';\r\n\t};\r\n\r\n\tconst _display_win = () => {\r\n\t\tconst alert_element = document.querySelector('.alert');\r\n\t\talert_element.classList.remove('description');\r\n\t\talert_element.textContent = 'You win!';\r\n\t};\r\n\r\n\tconst _display_boards = () => {\r\n\t\t// Board that displays the player's ships and where the CPU attacked\r\n\t\tconst player_board = document.querySelector('.player-board');\r\n\r\n\t\t// Board that displays where the user has attacked\r\n\t\tconst attack_board = document.querySelector('.attack-board');\r\n\r\n\t\tfor (let r = 0; r < gb_player.grid.length; r++) {\r\n\t\t\tfor (let c = 0; c < gb_player.grid[0].length; c++) {\r\n\t\t\t\tconst player_square = document.createElement('div');\r\n\t\t\t\tplayer_square.setAttribute('data-row', r + '');\r\n\t\t\t\tplayer_square.setAttribute('data-col', c + '');\r\n\t\t\t\tplayer_square.classList.add('player-square');\r\n\t\t\t\tplayer_square.classList.add('square-empty');\r\n\r\n\t\t\t\t// Event listeners for dragging and dropping ships\r\n\t\t\t\tplayer_square.addEventListener('dragover', (e) => {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t});\r\n\r\n\t\t\t\tplayer_square.addEventListener('drop', (e) => {\r\n\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\tconst cur_row = Number(e.target.getAttribute('data-row'));\r\n\t\t\t\t\tconst cur_col = Number(e.target.getAttribute('data-col'));\r\n\r\n\t\t\t\t\tlet start_row = -1;\r\n\t\t\t\t\tlet start_col = -1;\r\n\t\t\t\t\tlet end_row = -1;\r\n\t\t\t\t\tlet end_col = -1;\r\n\t\t\t\t\tconst ship = standard_ships[dragged_ship];\r\n\t\t\t\t\t// Calculate where the ship should be placed\r\n\t\t\t\t\tif (is_dragged_horiz) {\r\n\t\t\t\t\t\tstart_row = cur_row;\r\n\t\t\t\t\t\tend_row = cur_row;\r\n\t\t\t\t\t\tstart_col = cur_col - dragged_ship_square;\r\n\t\t\t\t\t\tend_col = start_col + ship.length - 1;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstart_col = cur_col;\r\n\t\t\t\t\t\tend_col = cur_col;\r\n\t\t\t\t\t\tstart_row = cur_row - dragged_ship_square;\r\n\t\t\t\t\t\tend_row = start_row + ship.length - 1;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t// Place the ship and hide it if successful\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tlast_clicked_ship &&\r\n\t\t\t\t\t\t\tgb_player.place_ship(\r\n\t\t\t\t\t\t\t\tship,\r\n\t\t\t\t\t\t\t\tstart_row,\r\n\t\t\t\t\t\t\t\tstart_col,\r\n\t\t\t\t\t\t\t\tend_row,\r\n\t\t\t\t\t\t\t\tend_col\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t// Hide ship\r\n\t\t\t\t\t\t\tdocument\r\n\t\t\t\t\t\t\t\t.querySelector('.' + dragged_ship)\r\n\t\t\t\t\t\t\t\t.classList.add('hidden');\r\n\t\t\t\t\t\t\tconst squares = _get_squares(\r\n\t\t\t\t\t\t\t\t'player-square',\r\n\t\t\t\t\t\t\t\tstart_row,\r\n\t\t\t\t\t\t\t\tstart_col,\r\n\t\t\t\t\t\t\t\tend_row,\r\n\t\t\t\t\t\t\t\tend_col\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t_update_display(squares, gb_player.SQUARE_SHIP);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tconsole.table(gb_player.grid);\r\n\t\t\t\t\t} catch (err) {\r\n\t\t\t\t\t\tconst alert_element = document.querySelector('.alert');\r\n\t\t\t\t\t\talert_element.classList.remove('description');\r\n\t\t\t\t\t\talert_element.textContent = err.message;\r\n\t\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\t\talert_element.textContent = '';\r\n\t\t\t\t\t\t}, 3000);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconsole.log('dropped', e.target);\r\n\t\t\t\t\tconsole.log(dragged_ship, dragged_ship_square);\r\n\t\t\t\t});\r\n\r\n\t\t\t\tplayer_board.appendChild(player_square);\r\n\r\n\t\t\t\tconst attack_square = document.createElement('div');\r\n\t\t\t\tattack_square.setAttribute('data-row', r + '');\r\n\t\t\t\tattack_square.setAttribute('data-col', c + '');\r\n\t\t\t\tattack_square.classList.add('attack-square');\r\n\t\t\t\tattack_square.classList.add('square-empty');\r\n\t\t\t\tattack_board.appendChild(attack_square);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tconst _get_squares = (\r\n\t\tclass_name,\r\n\t\tstart_row,\r\n\t\tstart_col,\r\n\t\tend_row,\r\n\t\tend_col\r\n\t) => {\r\n\t\tlet squares = [];\r\n\t\tif (start_row === end_row) {\r\n\t\t\t// Ship is horizontal\r\n\t\t\tfor (let c = start_col; c <= end_col; c++) {\r\n\t\t\t\tsquares.push(\r\n\t\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\t`.${class_name}[data-row=\"${start_row}\"][data-col=\"${c}\"]`\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Ship is vertical\r\n\t\t\tfor (let r = start_row; r <= end_row; r++) {\r\n\t\t\t\tsquares.push(\r\n\t\t\t\t\tdocument.querySelector(\r\n\t\t\t\t\t\t`.${class_name}[data-row=\"${r}\"][data-col=\"${start_col}\"]`\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn squares;\r\n\t};\r\n\r\n\tconst _update_display = (squares, option) => {\r\n\t\tlet added_class_name = 'square-empty';\r\n\t\tswitch (option) {\r\n\t\t\tcase gb_player.SQUARE_EMPTY:\r\n\t\t\t\tadded_class_name = 'square-empty';\r\n\t\t\t\tbreak;\r\n\t\t\tcase gb_player.SQUARE_SHIP:\r\n\t\t\t\tadded_class_name = 'square-ship';\r\n\t\t\t\tbreak;\r\n\t\t\tcase gb_player.SQUARE_HIT:\r\n\t\t\t\tadded_class_name = 'square-hit';\r\n\t\t\t\tbreak;\r\n\t\t\tcase gb_player.SQUARE_SHIP_HIT:\r\n\t\t\t\tadded_class_name = 'square-ship-hit';\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tsquares.forEach((sq) => {\r\n\t\t\tconsole.log(sq.classList[1]);\r\n\t\t\tsq.classList.replace(sq.classList[1], added_class_name);\r\n\t\t\tconsole.log(sq.classList[1]);\r\n\t\t});\r\n\t};\r\n\r\n\t// Runs when object is created\r\n\tconst play = () => {\r\n\t\t_init_window();\r\n\t\t_init_start_game_btn();\r\n\t\t_display_boards();\r\n\t\t_init_attack_squares();\r\n\t\t_init_ships();\r\n\t\t_init_restart_btn();\r\n\t\t_init_info_btn();\r\n\t};\r\n\r\n\treturn { play };\r\n};\r\n\r\nmodule.exports = DOM;\r\n\n\n//# sourceURL=webpack://18-battleship/./src/components/dom.js?");

/***/ }),

/***/ "./src/components/gameboard.js":
/*!*************************************!*\
  !*** ./src/components/gameboard.js ***!
  \*************************************/
/***/ ((module) => {

eval("const Gameboard = () => {\r\n\tconst NUM_ROWS = 10;\r\n\tconst NUM_COLS = 10;\r\n\tconst SQUARE_EMPTY = 0;\r\n\tconst SQUARE_SHIP = 1;\r\n\tconst SQUARE_HIT = 2;\r\n\tconst SQUARE_SHIP_HIT = 3;\r\n\r\n\t// Map holds \"row_num col_num\" : Ship object\r\n\tlet ships_map = new Map();\r\n\r\n\tconst _init_board = () => {\r\n\t\tconst new_board = [];\r\n\t\tfor (let i = 0; i < NUM_ROWS; i++) {\r\n\t\t\tnew_board.push([]);\r\n\t\t\tfor (let j = 0; j < NUM_COLS; j++) {\r\n\t\t\t\tnew_board[i].push(SQUARE_EMPTY);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn new_board;\r\n\t};\r\n\r\n\tlet grid = _init_board();\r\n\r\n\t// Distance formula\r\n\tconst _distance = (start_row, start_col, end_row, end_col) => {\r\n\t\tconst dist = Math.sqrt(\r\n\t\t\tMath.pow(start_row - end_row, 2) + Math.pow(start_col - end_col, 2)\r\n\t\t);\r\n\t\tif (Number.isInteger(dist)) {\r\n\t\t\treturn dist;\r\n\t\t}\r\n\r\n\t\t// Return -1 if distance is not an integer\r\n\t\t// Can happen if user tries to place a ship diagonally\r\n\t\treturn -1;\r\n\t};\r\n\r\n\t// Returns false if ship overlaps with another ship\r\n\t// Returns true otherwise\r\n\tconst place_ship = (ship, start_row, start_col, end_row, end_col) => {\r\n\t\t// Add one to distance to include start as part of the distance\r\n\t\t// i.e. if start_row = end_row = 1 and start_col = end_col = 1,\r\n\t\t// traditional distance formula would say that distance = 0, but we want it to be 1\r\n\t\tconsole.log('in place_ship', {\r\n\t\t\tship,\r\n\t\t\tstart_row,\r\n\t\t\tstart_col,\r\n\t\t\tend_row,\r\n\t\t\tend_col,\r\n\t\t});\r\n\t\tconst distance = _distance(start_row, start_col, end_row, end_col) + 1;\r\n\r\n\t\t// Input validation\r\n\t\tif (\r\n\t\t\tMath.min(start_row, start_col, end_row, end_col) < 0 ||\r\n\t\t\tMath.max(start_row, end_row) >= NUM_ROWS ||\r\n\t\t\tMath.max(start_col, end_col) >= NUM_COLS\r\n\t\t) {\r\n\t\t\tthrow new Error('Cannot place ship out of bounds');\r\n\t\t} else if (distance === 0) {\r\n\t\t\tthrow new Error('Cannot place ship diagonally');\r\n\t\t} else if (ship.length < distance) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Selected start and end are too large for this ship'\r\n\t\t\t);\r\n\t\t} else if (ship.length > distance) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Selected start and end are too small for this ship'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Place the ship on the board\r\n\t\tif (start_row === end_row) {\r\n\t\t\t// Ship is placed horizontally\r\n\t\t\tlet cur_col = Math.min(start_col, end_col);\r\n\t\t\tlet stop_col = Math.max(start_col, end_col);\r\n\r\n\t\t\tfor (let c = cur_col; c <= stop_col; c++) {\r\n\t\t\t\t// Check if square is taken by another ship\r\n\t\t\t\tif (ships_map.has(`${start_row} ${c}`)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let c = cur_col; c <= stop_col; c++) {\r\n\t\t\t\tgrid[start_row][c] = SQUARE_SHIP;\r\n\t\t\t\tships_map.set(`${start_row} ${c}`, ship);\r\n\t\t\t}\r\n\t\t} else if (start_col == end_col) {\r\n\t\t\t// Ship is placed vertically\r\n\t\t\tlet cur_row = Math.min(start_row, end_row);\r\n\t\t\tlet stop_row = Math.max(start_row, end_row);\r\n\r\n\t\t\tfor (let r = cur_row; r <= stop_row; r++) {\r\n\t\t\t\t// Check if square is taken by another ship\r\n\t\t\t\tif (ships_map.has(`${r} ${start_col}`)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor (let r = cur_row; r <= stop_row; r++) {\r\n\t\t\t\tgrid[r][start_col] = SQUARE_SHIP;\r\n\t\t\t\tships_map.set(`${r} ${start_col}`, ship);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\t// Return false if user has already hit this square\r\n\t// Returns true otherwise\r\n\tconst receive_attack = (row, col) => {\r\n\t\tif (\r\n\t\t\tgrid[row][col] === SQUARE_HIT ||\r\n\t\t\tgrid[row][col] == SQUARE_SHIP_HIT\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst key = `${row} ${col}`;\r\n\t\tif (ships_map.has(key)) {\r\n\t\t\tconst ship = ships_map.get(key);\r\n\t\t\tship.hit();\r\n\r\n\t\t\tships_map.delete(key);\r\n\t\t\tgrid[row][col] = SQUARE_SHIP_HIT;\r\n\t\t} else {\r\n\t\t\tgrid[row][col] = SQUARE_HIT;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t};\r\n\r\n\tconst place_all_random = (ships) => {\r\n\t\tfor (let i = 0; i < ships.length; i++) {\r\n\t\t\tconst ship = ships[i];\r\n\t\t\tlet rand_coords = _generate_rand_pos(ship.length);\r\n\t\t\tplace_ship(\r\n\t\t\t\tship,\r\n\t\t\t\trand_coords[0],\r\n\t\t\t\trand_coords[1],\r\n\t\t\t\trand_coords[2],\r\n\t\t\t\trand_coords[3]\r\n\t\t\t);\r\n\t\t}\r\n\t};\r\n\r\n\t// 2 different directions (veritcal and horizontal)\r\n\t// 0 = vertical\r\n\t// 1 = horizontal\r\n\tconst _generate_rand_end = (start_row, start_col, ship_length) => {\r\n\t\tconst rand_direction = Math.floor(Math.random() * 2);\r\n\t\tlet rand_row_end = start_row;\r\n\t\tlet rand_col_end = start_col;\r\n\t\tif (rand_direction === 0) {\r\n\t\t\t// Place vertically\r\n\t\t\trand_row_end = start_row + ship_length - 1;\r\n\t\t} else {\r\n\t\t\t// Place horizontally\r\n\t\t\trand_col_end = start_col + ship_length - 1;\r\n\t\t}\r\n\r\n\t\treturn [rand_row_end, rand_col_end];\r\n\t};\r\n\r\n\t// Checks if there is a ship placed in between the given rows and columns\r\n\tconst _check_has_ship = (start_row, start_col, end_row, end_col) => {\r\n\t\tif (start_row === end_row) {\r\n\t\t\t// Ship is horizontal\r\n\t\t\tconst start = Math.min(start_col, end_col);\r\n\t\t\tconst end = Math.max(start_col, end_col);\r\n\t\t\tfor (let c = start; c <= end; c++) {\r\n\t\t\t\tif (grid[start_row][c] === SQUARE_SHIP) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (start_col === end_col) {\r\n\t\t\t// Ship is vertical\r\n\t\t\tconst start = Math.min(start_row, end_row);\r\n\t\t\tconst end = Math.max(start_row, end_row);\r\n\t\t\tfor (let r = start; r <= end; r++) {\r\n\t\t\t\tif (grid[r][start_col] === SQUARE_SHIP) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t};\r\n\r\n\tconst _generate_rand_pos = (ship_length) => {\r\n\t\tlet rand_start_row = 0;\r\n\t\tlet rand_start_col = 0;\r\n\t\tlet rand_ends = [];\r\n\r\n\t\twhile (true) {\r\n\t\t\trand_start_row = Math.floor(Math.random() * NUM_ROWS);\r\n\t\t\trand_start_col = Math.floor(Math.random() * NUM_COLS);\r\n\t\t\trand_ends = _generate_rand_end(\r\n\t\t\t\trand_start_row,\r\n\t\t\t\trand_start_col,\r\n\t\t\t\tship_length\r\n\t\t\t);\r\n\r\n\t\t\tif (rand_ends[0] >= NUM_ROWS || rand_ends[1] >= NUM_COLS) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (\r\n\t\t\t\t!_check_has_ship(\r\n\t\t\t\t\trand_start_row,\r\n\t\t\t\t\trand_start_col,\r\n\t\t\t\t\trand_ends[0],\r\n\t\t\t\t\trand_ends[1]\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn [rand_start_row, rand_start_col, rand_ends[0], rand_ends[1]];\r\n\t};\r\n\r\n\t// Scans grid to see if there's still a square that has a ship\r\n\tconst check_lose = () => {\r\n\t\tfor (let r = 0; r < grid.length; r++) {\r\n\t\t\tfor (let c = 0; c < grid[0].length; c++) {\r\n\t\t\t\tif (grid[r][c] === SQUARE_SHIP) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t};\r\n\r\n\treturn {\r\n\t\tplace_ship,\r\n\t\treceive_attack,\r\n\t\tplace_all_random,\r\n\t\tcheck_lose,\r\n\t\tgrid,\r\n\t\tSQUARE_EMPTY,\r\n\t\tSQUARE_SHIP,\r\n\t\tSQUARE_HIT,\r\n\t\tSQUARE_SHIP_HIT,\r\n\t};\r\n};\r\n\r\nmodule.exports = Gameboard;\r\n\n\n//# sourceURL=webpack://18-battleship/./src/components/gameboard.js?");

/***/ }),

/***/ "./src/components/ship.js":
/*!********************************!*\
  !*** ./src/components/ship.js ***!
  \********************************/
/***/ ((module) => {

eval("const Ship = (length) => {\r\n\tif (typeof length !== 'number') {\r\n\t\tthrow new Error('Ship length has to be a number');\r\n\t} else if (length <= 0) {\r\n\t\tthrow new Error('Ship length has to be greater than 0');\r\n\t}\r\n\r\n\tlength = Math.floor(length);\r\n\tlet num_hits = 0;\r\n\r\n\tconst hit = () => {\r\n\t\tif (!is_sunk()) {\r\n\t\t\tnum_hits += 1;\r\n\t\t}\r\n\t};\r\n\r\n\tconst is_sunk = () => {\r\n\t\treturn num_hits === length;\r\n\t};\r\n\r\n\treturn { length, hit, is_sunk };\r\n};\r\n\r\nmodule.exports = Ship;\r\n\n\n//# sourceURL=webpack://18-battleship/./src/components/ship.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const Ship = __webpack_require__(/*! ./components/ship */ \"./src/components/ship.js\");\r\nconst Gameboard = __webpack_require__(/*! ./components/gameboard */ \"./src/components/gameboard.js\");\r\nconst DOM = __webpack_require__(/*! ./components/dom */ \"./src/components/dom.js\");\r\n\r\nfunction main() {\r\n\tconst dom = DOM();\r\n\tdom.play();\r\n}\r\n\r\nwindow.addEventListener('load', main);\r\n\n\n//# sourceURL=webpack://18-battleship/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;